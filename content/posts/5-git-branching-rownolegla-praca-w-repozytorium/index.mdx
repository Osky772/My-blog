---
title: Git branching - rÃ³wnolegÅ‚a praca w repozytorium
date: 2020-08-27
tags:
  - Git
---

import { jsx, Link as TLink } from "theme-ui"
import ExternalPostLink from '../../../src/components/ExternalPostLink.tsx';

CzeÅ›Ä‡, witaj w kolejnym artykule poÅ›wiÄ™conym podstawom Git'a ğŸ¤šğŸ˜€. W tym odcinku przyjrzymy siÄ™ tematowi branchÃ³w. JeÅ›li chcesz nauczyÄ‡ siÄ™ korzystaÄ‡ z narzÄ™dzia, ktÃ³re pozwoli Ci na pracÄ™ grupowÄ… w projekcie, to trafiÅ‚eÅ› w dobre miejsce ğŸ‘. W tym artykule chcÄ™ przedstawiÄ‡ Ci w prosty sposÃ³b ideÄ™ branchy i odczarowaÄ‡ strach przed ich swobodnym wykorzystaniem ğŸ§™â€â™‚ï¸.

## Dla kogo ten wpis?

Ten wpis przeznaczony jest dla osÃ³b poczÄ…tkujÄ…cych, ktÃ³rzy albo nie spotkali siÄ™ z branchami w praktyce, albo nie dokoÅ„ca wiedzÄ… jak siÄ™ z nimi obchodziÄ‡. W tym wpisie, przedstawiÄ™ Ci w Å‚atwy sposÃ³b koncepcjÄ™ branchy w Git'cie, pokaÅ¼Ä™ jakie problemy rozwiÄ…zujÄ… oraz przede wszystkim, jakie niosÄ… korzyÅ›ci. Ten wpis bÄ™dzie w formie poradnika/tutoriala. PrzeprowadzÄ™ CiÄ™ przez zachowanie branchy w praktyce oraz pokaÅ¼Ä™ przydatne komendy, ktÃ³re sÄ… niezbÄ™dne do efektywnej pracy. Mimo tego, Å¼e w tym wpisie nie dotkniemy mergowania branchy to zrozumiesz jak pracowaÄ‡ na osobnych branchach, dziÄ™ki czemu Å‚Ä…czenie osobnych branchy bÄ™dzie zrozumiaÅ‚e.

## SÅ‚owem wstÄ™pu...

Branche sÄ… na poczÄ…tku trudnym orzechem do zgryzienia. Trzeba dobrze zrozumieÄ‡ koncepcjÄ™ branchy i ich dziaÅ‚anie. UwaÅ¼am, Å¼e jest wiele poradnikÃ³w na temat Git'a, ktÃ³re sÄ… bardzo dobre, ale jednoczeÅ›nie potrafiÄ… byÄ‡ bardzo obszerne, przez co trudniej jest zaÅ‚apaÄ‡ sens i faktycznie zaczÄ…Ä‡ korzystaÄ‡ z omawianego narzÄ™dzia. Mimo masy poradnikÃ³w na temat Git'a, chcÄ™ doÅ‚oÅ¼yÄ‡ swojÄ… cegieÅ‚kÄ™ do tej konstrukcji i pomÃ³c osobom poczÄ…tkujÄ…cym rozpoczÄ™cie efektywnej i pewnej pracy w Git'cie.

> ğŸ‘‰ ZachÄ™cam zaawansowanych uÅ¼ytkownikÃ³w do przeczytania tego artykuÅ‚u i podzielenia siÄ™ swoimi przemyÅ›leniami oraz wÅ‚asnym doÅ›wiadczeniem w sekcji komentarzy. Podzielenie siÄ™ swojÄ… wiedzÄ… i przydanymi linkami moÅ¼e pomÃ³c nie tylko mi, ale przede wszystkim osobom, ktÃ³re dopiero zaczynajÄ… swojÄ… przygodÄ™ z programowaniemğŸ’¡

## TrochÄ™ mojej historii...

PamiÄ™tam, Å¼e nauka Git'a nie przychodziÅ‚a mi Å‚atwo. WiedziaÅ‚em po co jest Git i mniej wiÄ™cej wiedziaÅ‚em jak go obsÅ‚ugiwaÄ‡, ale nie miaÅ‚em pewnoÅ›ci w tym co robiÄ™. Jedynie z Å‚atwoÅ›ciÄ… przychodziÅ‚o mi commitowanie mojej pracy w projektach, ktÃ³re sam robiÅ‚em (stronki internetowej, Ä‡wiczenia z JS'a, aplikacje webowe). O takiej podstawowej pracy w repozytorium pisaÅ‚em w <TLink href="https://www.oskarkowalow.pl/blog/git-podstawowa-praca-w-lokalnym-repozytorium">poprzednim wpisie</TLink>. Wpis ten miaÅ‚ pokazaÄ‡ podstawowÄ… pracÄ™ 
w projekcie przy uÅ¼yciu Git'a i przeÅ‚amaÄ‡ opory do jego uÅ¼ywania. To co tam napisaÅ‚em, to taki podstawowy workflow podczas samodzielnej pracy nad konkretnym zadaniem. I taki model pracy sprawdza siÄ™, ale problem pojawia siÄ™ w pracy grupowej... a bez branchy nie ma pracy grupowej. 

NajwiÄ™kszym powodem mojej frustracji byÅ‚y branche w Git'cie. Kiedy byÅ‚em na kursie programowania, musieliÅ›my tworzyÄ‡ projekty w grupach (strona internetowa, gra w JS'ie i apliakcja webowa). No i tu siÄ™ zaczynaÅ‚ problem. MajÄ…c dosÅ‚ownie drobne pojÄ™cie o Git'cie, zaczÄ™liÅ›my pracÄ™ w zdalnym repozytorium na Githubie i kaÅ¼dy miaÅ‚ robiÄ‡ swoje konkretne zadanie na osobnych branchach. To byÅ‚a rzeÅºnia, jedno wielkie spaghetti i caÅ‚kowita niepewnoÅ›Ä‡ ğŸ¤¦â€â™‚ï¸. Po prostu nie rozumiaÅ‚em dobrze o co chodzi w branchach i jak to faktycznie powinno wyglÄ…daÄ‡. PracowaÅ‚em po omacku, a i tak koÅ„czyÅ‚o siÄ™ na tym, Å¼e ktoÅ› caÅ‚kowicie nadpisaÅ‚ pracÄ™ kolegi z zespoÅ‚u, bo poÅ‚Ä…czyÅ‚ osobne branche, usuwajÄ…c przy okazji czyiÅ› kod.

TakÅ¼e praca w Git'cie to nie jest prosta sprawa, tym bardziej jak pracuje siÄ™ w grupie i dopiero zaczyna siÄ™ swojÄ… przygodÄ™ z tym narzÄ™dziem. Dlatego teraz piszÄ™ artykuÅ‚y o Git'cie, bo chcÄ™ Ci tych frustracji oszczÄ™dziÄ‡. WierzÄ™, Å¼e wystarczy dobrze zrozumieÄ‡ podstawy i moÅ¼na swobodnie zaczÄ…Ä‡ korzystaÄ‡ z tego narzÄ™dzia. Git umoÅ¼liwia pracÄ™ w grupie i generalnie jest prosty w codziennym uÅ¼ytkowaniu. To czym siÄ™ podzielÄ™ w tym wpisie, to wiedza, ktÃ³rej uÅ¼ywam na codzieÅ„ i osobiÅ›cie rzadko robiÄ™ coÅ› ponad ten workflow.

## Po co te branche?

Branch (ang. *gaÅ‚Ä…Åº*) w Git'cie oznacza odgaÅ‚Ä™zienie od gÅ‚Ã³wnej linii developmentu i rozpoczÄ™cie pracy nad czÄ™Å›ciÄ… aplikacji w separacji. TworzÄ…c repozytorium, do dyspozycji mamy domyÅ›lny branch o nazwie *master*. Z poprzedniego wpisu wiemy jak commitowaÄ‡ swojÄ… pracÄ™ na tym branchu (nieÅ›wiadomie rozpoczeliÅ›my pracÄ™ z branchami ğŸ˜„). Na domyÅ›lnym branchu *master* trzymamy **pewny, dziaÅ‚ajÄ…cy** kod. Pewny i dziaÅ‚ajÄ…cy kod to taki, co do ktÃ³rego mamy pewnoÅ›Ä‡, Å¼e w tym momencie w czasie, nasza strona lub aplikacja speÅ‚nia nasze oczekiwania co do funkcjonalnoÅ›ci i niezawodnoÅ›ci. Hmm... Z tÄ… niezawodnoÅ›ciÄ… bywa rÃ³Å¼nie, ale o tym za chwilÄ™ ğŸ˜…. 

DodajÄ…c nowÄ… funkcjonalnoÅ›Ä‡ do naszej aplikacji, tworzymy osobnÄ… gaÅ‚Ä…Åº o nazwie, ktÃ³ra w telegraficznym skrÃ³cie opisuje naszÄ… intencjÄ™. JeÅ›li chcemy dodaÄ‡ footer na stronie, to przykÅ‚adowa nazwa brancha moÅ¼e mieÄ‡ nazwÄ™ *add-footer*. Z tego miejsca (na nowej gaÅ‚Ä™zi) rozpoczynamy swojÄ… pracÄ™ nad dodaniem footera. CaÅ‚y kod, ktÃ³ry znajdowaÅ‚ siÄ™ na gÅ‚Ã³wnym branchu *master*, jest rÃ³wnieÅ¼ dostÄ™pny na nowo stworzonym branchu. Po napisaniu nowej funkcjnolanoÅ›ci, czyli w naszym przypadku dodanie footera na stronie, mamy gotowy kod, ktÃ³ry dziaÅ‚a i z ktÃ³rego jestesmy zadowoleni. Ale nasz gÅ‚Ã³wny branch *master* nie zawiera footera. Footer znajduje siÄ™ na osobnej gaÅ‚Ä™zi *add-footer*. WiÄ™c *master* przypomina pieÅ„ drzewa (pewny, stabilny kod) a *add-footer* jest gaÅ‚Ä™ziÄ… (nowy kod). Takich gaÅ‚Ä™zi moÅ¼emy mieÄ‡ nieskoÅ„czonÄ… iloÅ›Ä‡, np. *add-header*, *file-list-on-sidebar* etc. Aby branch *master* zawieraÅ‚ nowy kod, ktÃ³ry jest na inym branchu to musimy scaliÄ‡ oba te branche (tzw. merging). Po mergu, branch *master* zawiera kod, ktÃ³ry miaÅ‚ poprzednio oraz nowo dodany kod, ktÃ³ry znajduje siÄ™ na branchu *add-footer*. Tym oto sposobem kaÅ¼dy z deweloperÃ³w moÅ¼e rozwijaÄ‡ nowÄ… czÄ™Å›Ä‡ aplikacji na osobnej gaÅ‚Ä™zi nie wchodzÄ…Ä‡ w konflikt z gÅ‚Ã³wnÄ… gaÅ‚Ä™ziÄ…. 

Ale po co osobne branche? Co by byÅ‚o, jeÅ›li kaÅ¼dy z deweloperÃ³w tworzyÅ‚by nowy kod na tym samym i jednym branchu? Po chwili byÅ‚oby tak, Å¼e kolega z zespoÅ‚u nadpisywaÅ‚by rÃ³wnolegle kod, ktÃ³ry ktoÅ› dodaÅ‚ w miÄ™dzyczasie (wystÄ…piÅ‚by tzw. konflikt). A praca na osobnej gaÅ‚Ä™zi nie spowoduje konfliktÃ³w, dopÃ³ki nie bÄ™dziemy chcieli scaliÄ‡ obu branchy, ktÃ³re zawierajÄ… zmiany w tych samych plikach i w tych samych miejscach w kodzie (o konfliktach moÅ¼e napiszÄ™ w nastÄ™pnych wpisach, daj znaÄ‡ co myÅ›lisz w komentarzach ğŸ™‚).

Konkluzja jest taka, Å¼e branche pozwalajÄ… na rÃ³wnolegÅ‚Ä… pracÄ™ w projekcie przez deweloperÃ³w. Nawet dla jednego dewelopera dobrze jest tworzyÄ‡ branche w projekcie, bo historia projektu jest bardziej przejrzysta. Zamiast wykonywaÄ‡ caÅ‚Ä… pracÄ™ na jednym branchu, Å‚atwiej jest Å›ledziÄ‡ historiÄ™ zmian w projekcie, bo zobaczymy, Å¼e czÄ™Å›Ä‡ pracy zostaÅ‚a wykonana na branchu, ktÃ³ry ma deskryptywnÄ… nazwÄ™.

OgÃ³lnie wiemy o co chodzi w branchach i po co siÄ™ je uÅ¼ywa. PrzejdÅºmy zatem do praktyki ğŸ‘¨â€ğŸ’»ğŸ‘©â€ğŸ’».

## Branche w piguÅ‚ce

W moim poprzednim wpisie, wyjaÅ›niÅ‚em jak stworzyÄ‡ lokalne repozytorium i jak zapisywaÄ‡ pliki w historii swojego projektu. TworzÄ…c lokalne repozytorium mamy do dyspozycji branch *master*. MoÅ¼na to sprawdziÄ‡ komendÄ… `git status`:

```shell
git status
On branch master
```

Pod komendÄ… `git status` znajdziemy informacje na jakim branchu siÄ™ znajdujemy. JeÅ¼eli mamy juÅ¼ jakÄ…Å› historiÄ™ commitÃ³w w repozytorium, to dziÄ™ki komendzie git log, zobaczysz, Å¼e commity tworzone byÅ‚y na branchu *master*:

```shell
git log
commit d884b50b0c9f42677594cd6fb92475d31da78108 (HEAD -> master)
```

Obok SHA commita zobaczysz `(HEAD -> master)`, co oznacza, Å¼e aktualnie jesteÅ›my na branchu *master*.

W gruncie rzeczy branch *master*, jak rÃ³wnieÅ¼ kaÅ¼dy inny branch, wskazuje na ostatni wykonany commit w danym branchu. Branch to taki odnoÅ›nik do ostatniego wykonanego commita i serii commitÃ³w wykonanej w przeszÅ‚oÅ›ci. Aktualnie bÄ™dÄ…c na branchu *master*, jesteÅ› jednoczeÅ›nie na ostatnim wykonanym commicie w tym branchu. W tym miejscu pliki majÄ… swojÄ… okreÅ›lonÄ… zawartoÅ›Ä‡, ktÃ³ra zapisana jest w pod postaciÄ… commita. 

## Tworzenie branchy

StwÃ³rzmy nowego brancha:

```shell
git branch text-in-readme
```

Teraz uruchamiajÄ…c komendÄ™ `git log` zobaczysz innÄ… informacjÄ™:

```shell
git log
commit d884b50b0c9f42677594cd6fb92475d31da78108 (HEAD -> master, text-in-readme)
```

Widzisz teraz obok znanej informacji `(HEAD -> master)` twojÄ… nowo stworzonÄ… nazwÄ™ brancha (*text-in-readme*). StworzyliÅ›my brancha ale oprÃ³cz samego stworzenia, nic nie zrobiliÅ›my. Dalej jesteÅ›my na branchu master. SkÄ…d wiemy, Å¼e jesteÅ›my na branchu master, a nie na branchu *text-in-readme*? TÄ… informacjÄ™ daje nam wskaÅºnik HEAD. To HEAD mÃ³wi nam w jakim momencie historii projektu siÄ™ znajdujemy (bo moÅ¼emy nie tylko przeÅ‚Ä…czaÄ‡ siÄ™ miÄ™dzy branchami ale rÃ³wnieÅ¼ miÄ™dzy commitami, aby cofnÄ…Ä‡ siÄ™ do konkretnej zmiany i zobaczyÄ‡ jak wyglÄ…daÅ‚a i dziaÅ‚aÅ‚a aplikacja w przeszÅ‚oÅ›ci). 

Na razie tylko stworzyliÅ›my brancha. DokÅ‚adnie to robi komenda:

```shell
git branch *nazwa-brancha*
```

PowyÅ¼sza komenda tworzy nowy branch.

## Przechodzenie miÄ™dzy branchami

PrzejdÅºmy sobie na nowego brancha i zrÃ³bmy na nim konkretnÄ… pracÄ™. TÄ… pracÄ… niech bÄ™dzie modyfikacja zawartoÅ›ci pliku README.txt (w swoim folderze mam tylko ten plik).

Pierwszym krokiem jest przejÅ›cie na nowo stworzonego brancha. PosÅ‚uÅ¼y nam do tego komenda `git checkout`:

```shell
git checkout text-in-readme
```

Jak widzisz, komenda `git checkout` przyjmuje jako argument nazwÄ™ brancha na ktÃ³rego chcesz przejÅ›Ä‡. Teraz sprawdÅºmy za pomocÄ… komendy `git status` co nam powie Git:

```shell
git status
On branch text-in-readme
nothing to commit, working tree clean
```

Widzmy, Å¼e udaÅ‚o nam siÄ™ przejÅ›Ä‡ na branch *text-in-readme*. Edytujmy plik i zrÃ³bmy commit:

```shell
echo 'Pierwsze zdanie w pliku' >> README.txt
git add README.txt
git commit -m "add example text to README"
```

Teraz juÅ¼ pierwsze praktyczne zastosowanie branchy. PorÃ³wnajmy sobie historiÄ™ brancha *master* z branchem *text-in-readme*. Wpiszmy komendÄ™ `git log` na branchu *text-in-readme*:

```shell
commit 539b86338103e23fb68e36f3e5f89f43ef91e488 (HEAD -> text-in-readme)
Author: Oskar KowalÃ³w <kowalow.oskar@gmail.com>
Date:  Sun Aug 23 12:42:14 2020 +0200

    add example text to README
    
commit c43a625742f940ab7077acfe0ad36ab8eb6a3ea9 (master)
Author: Oskar KowalÃ³w <kowalow.oskar@gmail.com>
Date:  Sat Aug 15 12:15:48 2020 +0200

    initial commit
```

Pierwszy commit od gÃ³ry to nasz najnowszy commit i widzimy, Å¼e jest wykonany na branchu *text-in-readme* (HEAD wskazuje nam gdzie jesteÅ›my). Commit poniÅ¼ej zostaÅ‚ wykonany na branchu *master* (i HEAD na niego nie wskazuje, bo nie jesteÅ›my na branchu *master*). UÅ¼yjmy sobie zmodyfikowanej komendy `git log` aby wyraÅºniej zobaczyÄ‡ tÄ™ rÃ³Å¼nicÄ™:

```shell
git log --oneline --decorate --graph --all
```

Ta komenda pokaÅ¼e nam historiÄ™ zmian na wszystkich branchach:

```shell
git log --oneline --decorate --graph --all
* fbea1b2 (HEAD -> text-in-readme) add second sentence to README file
* 2e0e649 add example text to README
* c43a625 (master) initial commit
```

Widzimy, Å¼e jedynie na branchu *text-in-readme* mamy nowe commity, podczas gdy branch *master* ma tylko jeden commit o tytule "initial commit".

PrzeÅ‚Ä…czmy siÄ™ na branch master i sprawdÅºmy historiÄ™ commitÃ³w:

```shell
commit c43a625742f940ab7077acfe0ad36ab8eb6a3ea9 (master)
Author: Oskar KowalÃ³w <kowalow.oskar@gmail.com>
Date:  Sat Aug 15 12:15:48 2020 +0200

    initial commit
```

Faktycznie, na branchu master mamy tylko jeden commit i nie ma w nim commitÃ³w z brancha *text-in-readme*! To jest najwaÅ¼niejsza informacja. Na osobnym branchu mamy pliki, ktÃ³re sÄ… w takim stanie, w jakim byÅ‚y podczas tworzenia ostatniego commita. PrzeÅ‚Ä…czanie siÄ™ miÄ™dzy branchami sprawia, Å¼e pliki zmieniajÄ… swojÄ… zawartoÅ›Ä‡ w danym repozytorium. 

## Cofanie siÄ™ w przeszÅ‚oÅ›Ä‡

StwÃ³rzmy sobie jeszcze jednego commita na branchu *text-in-readme* aby nasza historia byÅ‚a trochÄ™ wiÄ™ksza:

```shell
echo 'Drugie zdanie w pliku. Zatem kolejna zmiana' >> README.txt
git add README.txt
git commit -m "add second sentence to README file"
```

Teraz w naszej historii, na branchu *text-in-readme* mamy w sumie 3 commity. MoÅ¼emy cofnÄ…Ä‡ siÄ™ do poprzednich commitÃ³w i odtworzyÄ‡ zawartoÅ›Ä‡ plikÃ³w, ktÃ³ra znajdowaÅ‚a siÄ™ w momencie stowrzenia danego commita. Na ten moment mamy w pliku README.txt nastÄ™pujÄ…cÄ… zawartoÅ›Ä‡:

```
Pierwsze zdanie w pliku
Drugie zdanie w pliku. Zatem kolejna zmiana
```

ChcÄ…c przenieÅ›Ä‡ siÄ™ konkretnych commitÃ³w, musimy podaÄ‡ SHA danego commita. TÄ… informacjÄ™ znajdziemy uÅ¼ywajÄ…c znanej nam komendy `git log`. UÅ¼yjmy sobie zmodyfikowanej komendy `git log --oneline` dziÄ™ki, ktÃ³rej zobaczymy wybrane informacje o commicie w jednej linii (skrÃ³cone SHA commita, nazwa brancha i tytuÅ‚ commita):

```shell
git log --oneline
41e9935 (HEAD -> text-in-readme) add second sentence to README file
2e0e649 add example text to README
c43a625 (master) initial commit
```

Cofnijmy siÄ™ do poprzedniego commita uÅ¼ywajÄ…c jego SHA:

```shell
git checkout 2e0e649
```

Zobaczymy dÅ‚ugi komentarz od Git'a o tym, Å¼e HEAD jest odczepiony od brancha i teraz wskazuje na konkretny commit (wiÄ™c HEAD nie wskazuje ani na branch *master* ani na branch *text-in-readme* tylko na commit na ktÃ³ry siÄ™ przenieÅ›liÅ›my) oraz, Å¼e moÅ¼emy sobie eksperymentowaÄ‡ z plikami z tym commicie, tworzÄ…c nowe commity lub moÅ¼emy stworzyÄ‡ nowego brancha z tego commita, co da nam moÅ¼liwoÅ›Ä‡ pracy na nowym branchu bazujÄ…c na zawartoÅ›ci plikÃ³w z tego commita. 

Teraz nasza historia wyglÄ…da tak jak w poprzednim commicie:

```shell
$ git log --oneline
2e0e649 add example text to README
c43a625 (master) initial commit
```

I zawartoÅ›Ä‡ pliku README.txt teÅ¼ jest taka, jaka byÅ‚a w tym commicie:

```
Pierwsze zdanie w pliku
```

## RozbieÅ¼na historia

A co z naszym branchem *master*? PrzeÅ‚Ä…czmy siÄ™ na mastera i zobaczmy, co tam mamy:

```shell
git checkout master
git log --oneline
c43a625 (HEAD -> master) initial commit
```

Nasz branch *master* ma tylko jeden commit i zawartoÅ›Ä‡ pliku README.txt jest pusta. 


CzÄ™sto w projekcie jest tak, Å¼e pracujÄ…c sobie na osobnym branchu, okazuje siÄ™, Å¼e na branchu *master*, ktoÅ› juÅ¼ dÄ…Å¼yÅ‚ wykonaÄ‡ jakaÅ› pracÄ™. ZrÃ³bmy sobie takÄ… symulacjÄ™ i dodajmy commita w branchu *master* tworzÄ…c nowy plik:

```shell
touch nowy-plik.txt
git add nowy-plik.txt
git commit -m "add new file as an example"
```

Teraz mamy rozbieÅ¼nÄ… historiÄ™ w obu branchach. Na branchu *text-in-readme* mamy inne commity i zrobiliÅ›my innÄ… pracÄ™, i na branchu *master* teÅ¼ mamy inne commity oraz zrobiliÅ›my innÄ… pracÄ™. MoÅ¼emy zobaczyÄ‡ tÄ™ rozbieÅ¼noÅ›Ä‡ uÅ¼ywajÄ…c ponownie zmodyfikowanej komendy `git log` z dodatkowymi argumentami, aby zobaczyÄ‡ historiÄ™ commitÃ³w dla wszystkich branchy:

```shell
git log --oneline --decorate --graph --all
* 1d0fec0 (HEAD -> master) add new file as an example
| * fbea1b2 (text-in-readme) add second sentence to README file
| * 2e0e649 add example text to README
|/
* c43a625 initial commit
```

Generalnie ten graf pokazuje nam efekt wykonanej pracy na naszych obu branchach wraz z historiÄ… commitÃ³w na tych branchach. WidaÄ‡, Å¼e branch *master* ma innÄ… historiÄ™ od brancha *text-in-readme* i te zmiany sÄ… zrÃ³Å¼nicowane, na co wskazuje graficzne rozgaÅ‚Ä™zienie. Branch *text-in-readme* staÅ‚ siÄ™ dosÅ‚ownie osobnÄ… gaÅ‚Ä™ziÄ… wraz z swojÄ… historiÄ™ zmian i swojÄ… zawartoÅ›ciÄ… plikÃ³w, podczas gdy branch *master* teÅ¼ ma swojÄ…, osobnÄ… historiÄ™ zmian i zawartoÅ›Ä‡ plikÃ³w. 

## Co moÅ¼na zrobiÄ‡ z branchami?

W tym momencie moÅ¼emy zdecydowaÄ‡, Å¼e chcemy mieÄ‡ poÅ‚Ä…czone oba branche i do naszego gÅ‚Ã³wnego brancha *master* chcemy dorzuciÄ‡ pliki znajdujÄ…ce siÄ™ na branchu *text-in-readme*. Takie scalenie branchy nazywa siÄ™ merging. Takiego scalenia dokonuje siÄ™ w momencie, kiedy na danym branchu skoÅ„czyliÅ›my tworzyÄ‡ jakÄ…Å› pracÄ™ i jesteÅ›my gotowi doÅ‚Ä…czyÄ‡ nasze zmiany do gÅ‚Ã³wnej linii dewelopmentu, do gÅ‚Ã³wnego brancha, czyli do naszego pnia, brancha *master*, tam gdzie jesteÅ›my pewni, Å¼e nasza aplikacja lub strona wyglÄ…da i dziaÅ‚a tak jak powinna.

## Podsumowanie

PrzeszliÅ›my przez tworzenie branchy i na kaÅ¼dym branchu zrobiliÅ›my innÄ… pracÄ™ co spowodowaÅ‚o, Å¼e na obu branchach mamy osobnÄ… historiÄ™ zmian ğŸ‰. Jest to gÅ‚Ã³wna cecha branchy i to co jest najwaÅ¼niejsze podczas pracy z branchami. Zrozumienie, Å¼e kaÅ¼dy branch zawiera inne pliki i innÄ… historiÄ™ commitÃ³w to clue tego wpisu. W nastÄ™pnym artykule opowiem wiÄ™cej, jak poÅ‚Ä…czyÄ‡ te branche ze sobÄ… i na jakie problemy moÅ¼na siÄ™ natknÄ…Ä‡ podczas scalania branchy. 

W programowaniu waÅ¼ne jest, aby wiedzÄ™ dawkowaÄ‡ porcjami i nie ogarniaÄ‡ wszystko na raz. Lepiej jest skupiÄ‡ siÄ™ na danym zagadniemu trochÄ™ dÅ‚uÅ¼ej, aby potem mÃ³c Å‚atwiej wejÅ›Ä‡ na wyÅ¼szy poziom abstrakcji, czyli na bardziej zaawansowane zagadnienia, ktÃ³re wciÄ…Å¼ bazujÄ… na podstawach. 

Mam nadziejÄ™, Å¼e skutecznie przybliÅ¼yÅ‚em Wam pracÄ™ na branchach. JeÅ¼eli jest coÅ› niejasne, niezrozumiaÅ‚e, trudne do przyjÄ™cia lub pogmatwane to piszcie w komentarzach, a chÄ™tnie siÄ™ odniosÄ™ do wszelkich wÄ…tpliwoÅ›ci. MoÅ¼ecie teÅ¼ napisaÄ‡, jeÅ¼eli ten wpis zwyczajnie Wam siÄ™ podobaÅ‚, to rÃ³wnieÅ¼ jest dla mnie bardzo waÅ¼ne ğŸ¤š.