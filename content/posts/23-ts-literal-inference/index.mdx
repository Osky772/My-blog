---
title: Typescript - literal inference
date: 2021-10-07
tags:
  - Typescript
---

import { jsx, Link as TLink } from "theme-ui"
import ExternalPostLink from '../../../src/components/ExternalPostLink.tsx';
import Code from "@lekoarts/gatsby-theme-minimal-blog/src/components/code"

W Typescript moÅ¼emy trafiÄ‡ na bÅ‚Ä…d typu "Argument of type X is not assignable to parameter of type Y".
Co to oznacza i jak to naprawiÄ‡?

## Typy ogÃ³lne i typy dosÅ‚owne

W Typescript mamy typy ogÃ³lne, takie jak `string`, `number`, `boolean` i typy dosÅ‚owne, np. `"Oskar"` lub `123`.
NaprawdÄ™, zmienna moÅ¼e mieÄ‡ taki dosÅ‚owny typ.

DeklarujÄ…c zmiennÄ… i przypisujÄ…c do niej wartoÅ›Ä‡ prymitywnÄ…, moÅ¼emy uÅ¼yÄ‡ sÅ‚owa kluczowego `let` lub `const`.
W zaleÅ¼noÅ›ci od tego jak zadeklarujemy zmiennÄ…, bÄ™dzie miaÅ‚a ona inny typ.

```ts
let myName = "Oskar"; // zmienna ma typ "string"
const myRealName = "Oskar"; // zminna ma typ "Oskar"
```

Dzieje siÄ™ tak dlatego, Å¼e deklarujÄ…c zmiennÄ…Â sÅ‚owem kluczowym `let`, moÅ¼emy tÄ… zmiennÄ… nadpisaÄ‡ i przypisaÄ‡ do niej innÄ… wartoÅ›Ä‡ typu string.
W przypadku staÅ‚ej `const`, nasza zmienna jest read-only i nie mamy moÅ¼liwoÅ›ci jej nadpisania.
StaÅ‚Ä… `const`, z przypisanÄ… wartoÅ›ciÄ… prymitywnÄ…, Typescript oznaczy typem dosÅ‚ownym.

## Obiekty jako const

Z obiektami jest trochÄ™ inaczej.
TworzÄ…c obiekt i przypisujÄ…c go do zmiennej, przypisujemy de facto referencjÄ™ do tego obiektu, a nie dokÅ‚adnÄ… jego zawartoÅ›Ä‡.
StÄ…d nie ma znaczenia, czy obiekt zadeklarujemy jako `let` czy `const`, zawsze dostaniemy ogÃ³lny typ.

```ts
declare function possibleButtonProps (color: "white" | "black", size: "big" | "small"): void;

const buttonProps = {
    color: "white", // color jest typu string
    size: "big" // size jest typu string
};

// ğŸ’¥ BOOM. Argument of type 'string' is not assignable to parameter of type '"white" | "black"'
possibleButtonProps(buttonProps.color, buttonProps.size);
```

Jak to naprawiÄ‡?

ZakÅ‚adajÄ…c, Å¼e w przyszÅ‚oÅ›ci nie chcemy zmieniaÄ‡ tego obiektu, moim zdaniem, najlepszym sposobem na to bÄ™dzie oznaczenie obiektu jako `as const`.

```ts
const buttonProps = {
    color: "white",
    size: "big"
} as const;

// âœ… OK
possibleButtonProps(buttonProps.color, buttonProps.size);
```

`as const` dziaÅ‚a jak `const` ale dla typÃ³w.
Oznacza to, Å¼e wÅ‚aÅ›ciwoÅ›ci tego obiektu, sÄ…Â oznaczone jako `readonly`.
Podczas prÃ³by nadpisania wÅ‚aÅ›ciwoÅ›ci obiektu, Typescript wyrzuci nam bÅ‚Ä…d i nie pozwoli nadpisaÄ‡ tej wÅ‚aÅ›ciwoÅ›ci.
