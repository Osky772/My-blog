---
title: Broken Link Checker - znajdź popsute linki na stronie
date: 2021-04-22
tags:
  - npm
---

import { jsx, Link as TLink } from "theme-ui"
import Image from '../../../src/components/Image.tsx';
import ExternalPostLink from '../../../src/components/ExternalPostLink.tsx';

Z pewnością nie chciałbyś, aby na twojej stronie były niedziałające linki lub prowadzące do strony, która nie istnieje.

<Image src="./404-error.jpeg"/>

W przypadku małej strony można ręcznie sprawdzić, czy wszystkie linki działają, ale na większych stronach nie będzie to takie proste. Poza tym, jako programiści powinniśmy automatyzować powtarzalne czynności 🙂. I właśnie o automatyzacji będzie ten wpis!

Użyjemy bardzo fajnej biblioteki do sprawdzania popsutych linków, a jest to <ExternalPostLink name="broken-link-checker" url="https://github.com/stevenvachon/broken-link-checker"/>. 

Bibliotekę możemy używać na dwa sposoby: w wierszu poleceń oraz w kodzie poprzez API. Zaprezentuję obie opcje.

> **Instalacja:** Musimy mieć <ExternalPostLink name="zainstalowany NPM" url="https://www.npmjs.com/get-npm"/> oraz Node w wersji wiekszej lub równej 14.

### Spis treści
- [Użycie w wierszu poleceń](#uzycie-w-wierszu-polecen)
  - [Pomijanie linków](#pomijanie-linków)
  - [Skanowanie tylko jednej strony](#skanowanie-tylko-jednej-strony)
- [Użycie w kodzie](#uzycie-w-kodzie)


<h3 id="uzycie-w-wierszu-polecen">Użycie w wierszu poleceń</h3>

W celu użycia biblioteki w wierszu poleceń, zainstalujemy ją globalnie:

```shell
npm install broken-link-checker -g
```

Jeśli instalacja powiodła się, możemy sprawdzić dostępne argumenty:
```shell
blc --help
```

Typowe użycie w celu przeskanowania całej strony może wyglądać następująco:

```shell
# -r skanuje rekurencyjnie całą stronę, czyli również wszystkie podstrony
# -o zachowuje kolejność linków w jakiej pojawiają się na stronie
blc https://www.oskarkowalow.pl -ro
```

Powyższy skrypt uruchomi skanowanie strony internetowej. Tak wygląda fragment skanowania mojej strony:

<Image src="./blc-scanning.png"/>

Wynik skanowania jest bardzo czytelny i wiadomo, które linki działają, a które nie. Widać jednak, że linki prowadzące do Linkedin wyrzucają błąd. To zachowanie jest nie do ominięcia i linki prowadzące do Linkedin zawsze będą zwracać ten błąd. 

U mnie tak wygląda wynik zakończenia skanowania:

```
Finished! 682 links found. 578 excluded. 18 broken.
Elapsed time: 49 seconds
```

Moja strona jest jeszcze dość mała i skanowanie wszystkich podstron nie było zbyt czasochłonne.

<h4 id="pomijanie-linków">Pomijanie linków</h4>

Możemy pomijać skanowanie wybranych linków, aby przyspieszyć skanowanie lub pozbyć się linków, które zawsze zwracają błąd:

- `--exclude-external` lub `-e` spowoduje pominięcie wszystkich linków do zewnętrznych serwisów,
- `--exclude-internal` lub `-i` spowoduje pominięcie wszystkich wewnętrznych linków, a więc będzie sprawdzać tylko zewnętrzne linki,
- `--exclude` pozwala na pomijanie różnych ścieżek i wybranych linków.

Tak może wyglądać pominięcie linków do Linkedin oraz podstrony "blog/kategorie":
```shell
blc https://www.oskarkowalow.pl -ro \
--exclude linkedin \
--exclude /blog/kategorie
```

<h4 id="skanowanie-tylko-jednej-strony">Skanowanie tylko jednej strony</h4>

Czasem skanowanie wszystkich podstron może być bardzo czasochłonne, szczególnie jeżeli mamy bardzo duży serwis do sprawdzenia. W takim wypadku wystarczy odjąć flagę `-r`:

```shell
blc https://www.oskarkowalow.pl -o
```

<h3 id="uzycie-w-kodzie">Użycie w kodzie</h3>

Biblioteka udostępnia API, dzięki czemu możemy użyć jej w kodzie. Przykładowo, możemy napisać skrypt w Node JS, który będzie sprawdzał wybrane linki na stronie zanim pójdzie ona na produkcję. Może to być kolejny krok w ramach testów w naszym *Continues Integration*.

Zainstalujemy bibliotekę lokalnie, wewnątrz naszego projektu:
```shell
# instalujemy jako dev dependencję, gdyż jest potrzebna tylko podczas developmentu
npm install --save-dev broken-link-checker
```

Stwórzmy nowy plik w którym umieścimy cały nasz kod dotyczący skanowania wybranego URL:

```js
const { SiteChecker } = require('broken-link-checker');

const siteChecker = new SiteChecker(
  { 
    excludeInternalLinks: false,
    excludeExternalLinks: false, 
    filterLevel: 0,
    excludedKeywords: ["linkedin.com", "github.com"]
  },
  {
    "error": (error) => {
        console.error(error);
    },
    "link": (result) => {
      if (result.broken) {
        if (result.http.response && ![undefined, 200, 429].includes(result.http.response.statusCode)) {

          if (result.internal) {
            console.error(`broken internal link ${result.http.response.statusCode} => ${result.url.original}`);
          } else {
            console.warn(`broken external link ${result.http.response.statusCode} => ${result.url.original}`);
          }

        }
      }
    },
    "end": () => {
        console.log("CHECK FOR BROKEN LINKS FINISHED!");
    }
  }
);

siteChecker.enqueue("http://localhost:8000/");

```

Teraz prześledzimy sobie co dzieję się w powyższym kodzie.

Importujemy klasę `SiteChecker` i tworzymy jej nową instancję z obiektem konfiguracyjnym i eventami, na które chcemy nasłuchiwać. 

Chcemy skanować linki wewnętrzne, czyli należące do naszej strony (którą w linii 33 chcemy nasłuchiwać, czyli wywołać na URL skanowanie) oraz linki zewnętrze, czyli nie należące do nasego serwisu, np. google.com itd. 

Następnie wybieramy poziom <ExternalPostLink name="filtrowania" url="https://github.com/stevenvachon/broken-link-checker#filterlevel"/>, który ustawiliśmy na 0, tzn., chcemy skanować tylko tagi `a` oraz `area`, które muszą zawierać atrybut `href`.

Jest kilka linków, których nie chcemy skanować, a będzie to LinkedIn (który zawsze wyrzuci błąd) oraz Github, który prędko zacznie wyrzucać błąd <ExternalPostLink name="429" url="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429"/>. W `excludedKeywords` możemy też używać *glob patterns*, ale prostszych, z użyciem biblioteki <ExternalPostLink name="matcher" url="https://www.npmjs.com/package/matcher"/>.

Następnie zdefiniowaliśmy eventy na które chcemy nasłuchiwać. Jest ich sporo, ale nas najbardziej interesują 3: `error`, `link` i `end`.

Event `link` zostanie wyemitowany za każdym razem, gdy link został przeskanowany, działający lub zepsuty. Używając tego eventu, możemy uzyskać pełne informacje o linku, który został przeskanowany:

```js noLineNumbers
"link": (result) => {
  if (result.broken) {
    if (result.http.response && ![undefined, 200, 429].includes(result.http.response.statusCode)) {

      if (result.internal) {
        console.error(`broken internal link ${result.http.response.statusCode} => ${result.url.original} on page ${result.base.resolved}`);
      } else {
        console.warn(`broken external link ${result.http.response.statusCode} => ${result.url.original} on page ${result.base.resolved}`);
      }

    }
  }
},
```

W zasadzie wystarczająca może być informacja, że link jest zesputy, ale chcemy jeszcze przefiltorować informację sprawdzając `statusCode`. Status `200` nigdy nie powinien się tutaj pojawić, ale `undefined` już może. Dodatkowo wykluczymy sobie status `429` o którym już wspominałem. 

Dodatkowo dla zesputych linków wewnętrzych chcemy użyć `console.error`, a dla zewnętrzych `console.warn`, aby zaznaczyć, że najważniejsze dla nas są działające linki wewnętrzne. W logach zawieramy informację o `statusCode`, linku który jest zepsuty `result.url.original` oraz na jakiej stronie znajduje się ten link `result.base.resolved`.

> Nie każdy terminal będzie pokazywał poprawne kolory. `console.error` i `console.warn` mogą mieć biały font, a nie czerwony i żółty, których się spodziewamy. W celu zapewnienia takiego samego zachowania dla wszystkich programów, możemy posłużyć się biblioteką <ExternalPostLink name="chalk" url="https://github.com/chalk/chalk"/>.

Event `end` zostanie wyemitowany po ostatnim przeskanowym linku.

Przykładowo, w evencie `link` możemy dodawać wszystkie popsute linki do tablicy, a następnie w evencie `end` wyświetlić w konsoli całkowitą ilość popsutych linków wewnętrznych i zewnętrznych.

